#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

cd "$PROJECT_ROOT"

if tput colors &>/dev/null; then
  BOLD='\033[1m'
  BLUE='\033[34m'
  GREEN='\033[32m'
  YELLOW='\033[33m'
  RED='\033[31m'
  RESET='\033[0m'
else
  BOLD=''
  BLUE=''
  GREEN=''
  YELLOW=''
  RED=''
  RESET=''
fi

log() { echo >&2 -e "${BLUE}[init]${RESET} $*"; }
ok() { echo >&2 -e "${GREEN}✓${RESET} $*"; }
warn() { echo >&2 -e "${YELLOW}⚠${RESET} $*"; }
die() { echo >&2 -e "${RED}✗${RESET} $*"; exit 1; }

prompt_choice() {
  local prompt_text="$1"
  local default_idx="$2"
  shift 2
  local options=("$@")
  local choice

  echo >&2 ""
  echo >&2 -e "${BOLD}${prompt_text}${RESET}"
  for i in "${!options[@]}"; do
    echo >&2 "  $((i+1))) ${options[$i]}"
  done

  while true; do
    echo >&2 -n "Select (1-${#options[@]}) [default: ${default_idx}]: "
    read -r choice
    if [ -z "$choice" ]; then
      choice="$default_idx"
    fi
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#options[@]} ]; then
      echo "${options[$((choice-1))]}"
      return 0
    fi
    warn "Invalid selection. Enter a number between 1 and ${#options[@]}."
  done
}

prompt_text() {
  local prompt_text="$1"
  local default="${2:-}"
  local input

  echo >&2 ""
  if [ -n "$default" ]; then
    echo >&2 -n -e "${BOLD}${prompt_text}${RESET} [${default}]: "
  else
    echo >&2 -n -e "${BOLD}${prompt_text}${RESET}: "
  fi
  read -r input
  if [ -z "$input" ]; then
    echo "$default"
  else
    echo "$input"
  fi
}

set_env_kv() {
  local file="$1"
  local key="$2"
  local value="$3"
  local tmp

  tmp="$(mktemp)"
  if grep -qE "^[# ]*${key}=" "$file"; then
    # Replace first occurrence and uncomment.
    awk -v k="$key" -v v="$value" '
      BEGIN { done=0 }
      {
        if (!done && $0 ~ "^[# ]*" k "=") { print k "=" v; done=1; next }
        print
      }' "$file" > "$tmp"
  else
    cat "$file" > "$tmp"
    {
      echo ""
      echo "# ============================================================================"
      echo "# OVERRIDES (generated by scripts/init-odk.sh)"
      echo "# ============================================================================"
      echo "${key}=${value}"
    } >> "$tmp"
  fi
  mv "$tmp" "$file"
}

append_env_block() {
  local file="$1"
  shift
  {
    echo ""
    echo "# ============================================================================"
    echo "# OVERRIDES (generated by scripts/init-odk.sh)"
    echo "# ============================================================================"
    for kv in "$@"; do
      echo "$kv"
    done
  } >> "$file"
}

write_garage_toml() {
  local domain="$1"
  local rpc_secret="$2"

  mkdir -p garage
  cat > garage/garage.toml <<EOF
metadata_dir = "/data/meta"
data_dir = "/data/data"
db_engine = "lmdb"

replication_factor = 1

rpc_bind_addr = "[::]:3901"
rpc_secret = "${rpc_secret}"

[s3_api]
s3_region = "garage"
api_bind_addr = "[::]:3900"
root_domain = ".s3.${domain}"

[s3_web]
bind_addr = "[::]:3903"
root_domain = ".web.${domain}"
index = "index.html"
EOF
}

write_garage_compose_overlay() {
  local include_extra_hosts="$1" # true/false

  cat > docker-compose-garage.yml <<'EOF'
services:
  garage:
    image: dxflrs/garage:v2.1.0
    container_name: odk-garage
    command: ["./garage", "server"]
    ports:
      - 127.0.0.1:3900:3900
      - 127.0.0.1:3903:3903
    volumes:
      - garage_data:/data
      - ./garage/garage.toml:/etc/garage.toml:ro
    environment:
      RUST_LOG: info
    restart: always
EOF

  if [ "$include_extra_hosts" = "true" ]; then
    cat >> docker-compose-garage.yml <<'EOF'

  service:
    extra_hosts:
      - "odk-central.s3.${DOMAIN}:host-gateway"
EOF
  fi

  cat >> docker-compose-garage.yml <<'EOF'

volumes:
  garage_data: {}
EOF
}

log "ODK Central VG init (generates config files only)"

if [ ! -f ".env.template" ]; then
  die ".env.template not found in project root"
fi

ENV_TYPE="$(prompt_choice "Environment type:" 1 \
  "Dev (central.local / local machine)" \
  "Prod (real domain / server)")"

SSL_CHOICE="$(prompt_choice "SSL termination:" 1 \
  "upstream (recommended behind reverse proxy)" \
  "letsencrypt (ODK nginx manages certs)" \
  "customssl (ODK nginx uses your certs)" \
  "selfsign (dev only)")"

S3_CHOICE="$(prompt_choice "S3 blob storage:" 1 \
  "None (store blobs in PostgreSQL - simplest)" \
  "Garage (local S3 - optional)" \
  "External S3 (advanced)")"

DB_CHOICE="$(prompt_choice "Database:" 1 \
  "Container (postgres14 - default)" \
  "External PostgreSQL (advanced)")"

default_domain="central.local"
if [[ "$ENV_TYPE" == "Prod"* ]] && [[ "$SSL_CHOICE" != "selfsign"* ]]; then
  default_domain="central.example.com"
fi
DOMAIN="$(prompt_text "DOMAIN" "$default_domain")"

SYSADMIN_EMAIL="$(prompt_text "SYSADMIN_EMAIL" "admin@${DOMAIN}")"

SSL_TYPE="upstream"
HTTP_PORT="8080"
HTTPS_PORT="8443"
case "$SSL_CHOICE" in
  upstream*) SSL_TYPE="upstream"; HTTP_PORT="8080"; HTTPS_PORT="8443" ;;
  letsencrypt*) SSL_TYPE="letsencrypt"; HTTP_PORT="80"; HTTPS_PORT="443" ;;
  customssl*) SSL_TYPE="customssl"; HTTP_PORT="80"; HTTPS_PORT="443" ;;
  selfsign*) SSL_TYPE="selfsign"; HTTP_PORT="80"; HTTPS_PORT="443" ;;
esac

S3_SERVER=""
S3_BUCKET_NAME=""
VG_GARAGE_ENABLED="false"
EXTRA_SERVER_NAME=""
GARAGE_CAPACITY=""

case "$S3_CHOICE" in
  None*)
    ;;
  Garage*)
    VG_GARAGE_ENABLED="true"
    S3_BUCKET_NAME="odk-central"
    S3_SERVER="https://${S3_BUCKET_NAME}.s3.${DOMAIN}"
    # For letsencrypt + Garage, add extra names to the cert
    if [ "$SSL_TYPE" = "letsencrypt" ]; then
      EXTRA_SERVER_NAME="${S3_BUCKET_NAME}.s3.${DOMAIN} web.${DOMAIN}"
    fi
    # For selfsign, include SANs for both subdomains
    if [ "$SSL_TYPE" = "selfsign" ]; then
      EXTRA_SERVER_NAME="${S3_BUCKET_NAME}.s3.${DOMAIN} web.${DOMAIN}"
    fi
    GARAGE_CAPACITY="$(prompt_text "Garage node capacity (for cluster layout, e.g. 10G)" "10G")"
    ;;
  External*)
    S3_SERVER="$(prompt_text "S3_SERVER" "https://mybucket.s3.amazonaws.com")"
    S3_BUCKET_NAME="$(prompt_text "S3_BUCKET_NAME" "mybucket")"
    ;;
esac

DB_HOST=""
DB_USER=""
DB_PASSWORD=""
DB_NAME=""
DB_SSL=""

if [[ "$DB_CHOICE" == "External"* ]]; then
  DB_HOST="$(prompt_text "DB_HOST" "")"
  DB_USER="$(prompt_text "DB_USER" "odk")"
  DB_PASSWORD="$(prompt_text "DB_PASSWORD" "")"
  DB_NAME="$(prompt_text "DB_NAME" "odk")"
  DB_SSL="$(prompt_text "DB_SSL (null/true)" "true")"
fi

# ----------------------------------------------------------------------------
# Preserve existing secrets (idempotent re-runs)
# ----------------------------------------------------------------------------

backup_env() {
  if [ ! -f ".env" ]; then
    return 0
  fi
  local ts
  ts="$(date +%Y%m%d-%H%M%S)"
  local backup=".env.backup.${ts}"
  cp .env "$backup"
  warn "Backed up existing .env to ${backup}"
}

existing_s3_access=""
existing_s3_secret=""
if [ -f ".env" ]; then
  existing_s3_access="$(grep -E '^S3_ACCESS_KEY=' .env | tail -n 1 | cut -d= -f2- || true)"
  existing_s3_secret="$(grep -E '^S3_SECRET_KEY=' .env | tail -n 1 | cut -d= -f2- || true)"
fi

# ----------------------------------------------------------------------------
# Write .env (template + overrides)
# ----------------------------------------------------------------------------

backup_env

cp .env.template .env

set_env_kv .env DOMAIN "$DOMAIN"
set_env_kv .env SYSADMIN_EMAIL "$SYSADMIN_EMAIL"
set_env_kv .env SSL_TYPE "$SSL_TYPE"
set_env_kv .env HTTP_PORT "$HTTP_PORT"
set_env_kv .env HTTPS_PORT "$HTTPS_PORT"

append_kvs=()
append_kvs+=("VG_GARAGE_ENABLED=${VG_GARAGE_ENABLED}")

if [ -n "$EXTRA_SERVER_NAME" ]; then
  append_kvs+=("EXTRA_SERVER_NAME=\"${EXTRA_SERVER_NAME}\"")
fi

if [ -n "$DB_HOST" ]; then
  append_kvs+=("DB_HOST=${DB_HOST}" "DB_USER=${DB_USER}" "DB_PASSWORD=${DB_PASSWORD}" "DB_NAME=${DB_NAME}" "DB_SSL=${DB_SSL}")
fi

if [ -n "$S3_SERVER" ]; then
  append_kvs+=("S3_SERVER=${S3_SERVER}" "S3_BUCKET_NAME=${S3_BUCKET_NAME}")
  if [[ "$S3_CHOICE" == "External"* ]]; then
    s3_access="$(prompt_text "S3_ACCESS_KEY" "")"
    s3_secret="$(prompt_text "S3_SECRET_KEY" "")"
    append_kvs+=("S3_ACCESS_KEY=${s3_access}" "S3_SECRET_KEY=${s3_secret}")
  else
    # Garage: filled by scripts/add-s3.sh, but preserved on re-run if already set.
    if [ -n "$existing_s3_access" ] && [ -n "$existing_s3_secret" ]; then
      append_kvs+=("S3_ACCESS_KEY=${existing_s3_access}" "S3_SECRET_KEY=${existing_s3_secret}")
    else
      append_kvs+=("S3_ACCESS_KEY=" "S3_SECRET_KEY=")
    fi
  fi
fi

append_env_block .env "${append_kvs[@]}"

ok "Wrote .env"

# ----------------------------------------------------------------------------
# Garage config (generated, gitignored)
# ----------------------------------------------------------------------------

if [ "$VG_GARAGE_ENABLED" = "true" ]; then
  rpc_secret=""
  if [ -f "garage/garage.toml" ]; then
    rpc_secret="$(grep -E '^rpc_secret\\s*=\\s*"' garage/garage.toml | head -n 1 | sed -E 's/^rpc_secret\\s*=\\s*\"(.*)\"/\\1/' || true)"
  fi
  if [ -z "$rpc_secret" ]; then
    if command -v openssl >/dev/null 2>&1; then
      rpc_secret="$(openssl rand -hex 32)"
    elif command -v python3 >/dev/null 2>&1; then
      rpc_secret="$(python3 - <<'PY'
import secrets
print(secrets.token_hex(32))
PY
)"
    else
      die "Need openssl or python3 to generate Garage rpc_secret"
    fi
  fi

  write_garage_toml "$DOMAIN" "$rpc_secret"

  mkdir -p garage
  echo "${GARAGE_CAPACITY}" > garage/storage.conf

  include_extra_hosts="false"
  case "$DOMAIN" in
    *.local|localhost) include_extra_hosts="true" ;;
  esac
  write_garage_compose_overlay "$include_extra_hosts"

  ok "Wrote garage/garage.toml and docker-compose-garage.yml"
fi

log ""
log "${BOLD}Next steps${RESET}"
log "1) Create networks (once):"
log "   docker network create central_db_net || true"
log "   docker network create central_web || true"
log "2) Build:"
log "   docker compose build"
if [ "$VG_GARAGE_ENABLED" = "true" ]; then
  log "3) Start Garage only:"
  log "   docker compose -f docker-compose.yml -f docker-compose-garage.yml up -d garage"
  log "4) Bootstrap Garage (creates layout/key/bucket and updates .env):"
  log "   ./scripts/add-s3.sh"
  log "5) Start the full stack:"
  log "   docker compose -f docker-compose.yml -f docker-compose-garage.yml up -d"
else
  log "3) Start:"
  log "   docker compose up -d"
fi

ok "Init finished"
